---
title: "TCP报文格式、连接管理"
date: 2021-08-31T22:56:43+08:00
draft: true
toc: true
images:
tags: 
  - tcp
---

传输层(Transport Layer)是 OSI 协议的第四层协议，是唯一负责总体的数据传输和数据控制传输层的一层协议

## 传输层作用

网际层提供了主机之间的逻辑通道，通过寻址的方式，把数据包从一个主机发到另一个主机上。如果一个主机有多个进程同时在使用网络连接，那么数据包到达主机之后，如何区分它属于哪一个进程?为了区分数据包所属的进程，就需要用到传输层。

- 为网络应用程序提供接口
- 为端到端连接提供流量控制、差错控制、服务质量等管理服务
- 提供多路复用、多路分解机制

## 传输协议类型

针对不同情况下的额数据质量保证，传输层提哦给你了两种数据传输协议类型。

### 面向连接

通信双方在通信时，要事先建立一条通信线路，然后进行通信

1. 建立连接
2. 数据传输
3. 释放连接

### 无连接

通信双方不需要事先建立通信线路，而是把每个带有目的地址的包(报文分组)发送到线路上，由系统选定线路进行传输，不需要目标方进行回复。

## 端口和套接字

为了区分同一个主机上不同应用程序的数据包，传输层提供了端口和套接字概念。

数据链路层，MAC地址寻址来寻找局域网中的主机

网际层，通过IP地址来寻找网络中互连的主机或路由器

传输层，通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序

### 套接字

应用层通过传输层进行数据通信时，TCP和UDP会遇到需要同时为多个应用程序进程并发服务的问题。

多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据，为了区分不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了称为套接字的接口，区分不同应用程序进程间的网络通信和连接。

套接字是一个四元组，发送方IP:PORT,接收方IP:PORT

### 多路复用和多路分解

主机之间通信(进程通信)，往往同时需要运行多个应用程序。为了能够让一个计算机同时支持多个网络程序，并且同时保持与多台计算机进行连接，就需要用到多路复用和多路分解。

- 多路复用

  从源主机的不同套接字中收集数据块，并为每个数据块封装首部信息，从而生成报文段，然后将报文段传递到网络层中

- 多路分解

  将传输层报文段中的数据交付到正确的套接字

差不多就是扇入和扇出的意思。

## Netwox 建立TCP服务端客户端

### 简单通信

```
c1 netwox 89 -P 89 模拟服务端开启端口监听 89 端口
c2 netwox 87 -i c1 -p 89 连接 c1 89 端口'

```

### 远程操作-查看/下载/上传文件

```
c1 netwox 93 -P 7878
c2 netwox 95 -i c1 -p 7878 -f file_path/file_name  #查看文件内容
c2 netwox 95 -i c1 -p 7878 -f "file_path/file_name" -F 要保存到的文件名 # 下载文件
c2 netwox 96 -i c1 -p 7878 -f 文件 -F 服务端文件名
```

## TCP

传输控制协议 Transmission Control Protocol ,是一种面向连接的、可靠的、基于字节流的传输层控制协议。

TCP协议中，通过三次握手建立连接，通信结束后，还需要断开连接。如果没有被正确的发送到目的地时，将会重新发送数据包。

### 特性/作用

- 面向流的处理 以流的形式处理数据，把接收到的数据组成长度不等的段，在传递到网际层
- 重新排序 如果数据以错误的顺序到达目的地，TCP模块能够对数据重新排列，来恢复原始数据
- 流量控制 能够确保数据传输不会超过目的计算机接收数据的能力
- 优先级与安全 为TCP连接设置可选的优先级和安全级别
- 适当的关闭 以确保所有的数据被发送或接收以后，在进行关闭连接

## TCP数据格式

### 头部和封装

TCP在IP数据报中的封装 

[ IP头部协议(ipv4)/下一个头部(ipv6) ]  IPv4 为20字节，不带选项，IPv6为40字节

[ TCP头部 ] 20字节，不带选项，常见选项包括 最大段大小、时间戳、窗口缩放和选择性ACK

[ TCP(应用程序数据) ] 

### TCP头部

### 源端口和目的端口字段 

各占 16 位，2^16=65536

### 序列号字段

#### SEQ

Sequence Number，32位，表示本报文段所发送数据的第一个字节的编号，32位无符号数，到达2^32-1 后在循环到0，在TCP连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号，如果SYN的值时1时，这个字段的值就是初始序列值(ISN)，用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。

### 确认号字段

#### ACK

Acknowledgement Number，ACK Number,占32位。表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将收到的下一个序列号，也就是下一个接收的字节的序列号加1。

发送一个ACK与发送任何一个TCP报文段的开销是一样的，因为那个32位的ACK号字段一直都是头部的一部分，ACK位字段也一样。

### 数据偏移字段

#### TCP首部长度

Header Length,数据偏移是值数据段中数据部分起始处距离TCP数据段起始处的字节偏移量，占4位。也是在确定TCP数据段头部分的长度，告诉接受端的应用程序，数据从何处开始。

### 保留字段

#### Reserved 

占4位，为TCP将来的发展预留空间，目前全部为0。

### 标志位字段

#### CWR 

Congestion Window Reduce ，拥塞窗口减少标志，用来表明它收到了设置ECE标志的TCP包，并且，发送方收到消息之后，通过减少发送窗口的大小来降低发送速率。

#### ECE 

ECN Echo，用来在TCP三次握手时表明一个TCP段是具备ECN功能的，在数据传输过程中，它也用来表明接收到的TCP包的IP头部的ECN

被设置为11，即网络线路拥堵。

#### URG 

urgent，表示本报文段中发送的数据是否包含紧急数据，URG=1 时表示有紧急数据，当URG=1 时，后面的紧急指针字段才有效。

#### ACK

表示前面的确认号字段是否有效，ACK=1 时表示有效，只有当ACK=1 时，前面的确认号字段才有效，TCP规定，连接建立后，ACK必须为1。

TCP可以被描述为"一种带累积正向确认的滑动窗口协议"。

ACK号字段被构建用于指明在接受方已经顺序收到的最大字节(加1)。TCP还有一个选择确认(selective ACKnowledgment，SACK)选项。可以允许接受方告诉发送方它正确地接收到了次序杂乱的数据。每当一个具有选择重发(selective repeat) 能力的TCP发送方搭配时，就可以实现性能的显著改善

#### PSH 

Push，告诉对方收到该报文段后是否立即把数据推送给上层，如果值为1，表示应当立即把数据提交给上层，而不是缓存起来。

#### RST

表示是否重置连接，如果RST=1，说明TCP连接出现了严重错误(eg:主机崩溃)，必须释放连接，然后在重新建立连接。

#### SYN

在建立连接时使用，用来同步序号。

当SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段。

当SYN=1，ACK=1 时，表示对方同意建立连接。

SYN=1 说明这个是一个请求连接或同意建立连接的报文，只有在前两次握手中SYN才为1。

当建立一个新连接时，从客户机发送至服务器的第一个报文段的SYN位字段被启用。这样的报文段称为SYN报文段，或简单地称为SYN。然后序列号包含了在本次连接的这个方向上要使用的第一个序列号，后续序列号和返回的ACK号也在这个方向上(连接都是双向的)。⚠️这个数字不是0和1，而是另一个数字，经常时随机选择的，称为初始序列号(Initial Sequence Number，ISN)。ISN不是0和1，是因为这是一种安全措施。发送在本次连接的这个方向上的数据的第一个字节的序列号是ISN加1，因为SYN位字段会消耗一个序列号，消耗一个序列号也意味着使用重传进行可靠传输。因此SYN和应用程序字节(还有FIN)是被可靠传输的。不消耗序列号的ACK则不是。

#### FIN

标记数据是否发送完毕，如果FIN=1，表示数据已经发送完成，可以释放连接。

### 窗口大小字段

#### 窗口大小 

Window Size，16字节，表示从Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间，该字段可以用于TCP的流量控制。

### TCP检验和字段

#### 校验位

TCP CheckSum，占16位，用于确认传输的数据是否有损坏。

发送端基于数据内容校验生成一个数值，接受端根据接收的数据校验生成一个值，两个值必须相同，才能证明数据时有效的，如果两个值不同，则丢掉这个数据包。

Checksum 是根据伪头+TCP头+TCP数据三部分进行计算的。

### 紧急指针字段

#### 紧急指针

Urgent Pointer，仅当前面的URG控制位为1时才有意义。

指出本数据段中为紧急睡的字节数，占16位。当所有紧急数据处理完后，TCP就会告诉应用程序恢复到正常操作。即使当前窗口大小为0，也是可以发送紧急数据的，因为紧急数据无须缓存。

### 可选项字段

#### 选项

Option，长度不定，但长度必须是32bits的整数倍。

## TCP连接管理

### 建立连接

TCP是面向连接的单播协议，所以在发送数据之前，通信双方必须每次发出的请求都需要对方进行确认，在彼此之间建立一条连接。TCP客户端与TCP服务器在通信之前需要完成三次握手才能建立连接。

三次握手的目的不仅仅是让通信双方了解一个连接正在建立，双方具有通信的条件，还在于利用数据包的选项来承载特殊的信息。交换初始序列号(Initial Sequence Number，ISN)。

#### 第一次握手

客户端向服务器发送 SYN 报文段 (SEQ=SYN_client=1)，并指明想要连接的端口号和它的客户端初始序列号(ISN)， 并进入 SYN_SENT 状态，等待服务器确认。

SYN，SEQ=ISN_client

#### 第二次握手

- 服务器向客户端发送一个 SYN 报文段(SEQ=ISN_server)作为响应，并包含了它的初始序列号(ISN=ISN_server)，建立连接的请求，此时服务器进入 SYN_RECV 状态。
- 为了确认客户端的请求同步信息SYN，服务端将其包含的ISN数值加1后作为返回的ACK数值，回复客户端确认消息 (ACK=SYN_client+1)，每发送一个SYN,序列号就会自动加1.这样如果出现丢失的情况，该SYN段将会重传。

SYN+ACK，Seq=ISN_server，ACK=ISN_client+1

#### 第三次握手

客户端收到服务器的回复 (Seq+ACK 报文)，客户端在向服务端发送确认包 (ACK=ISN_server+1)，Seq=ISN_client+1，此包发送完毕客户端可服务器进入 ESTABLISHED 状态，完成三次握手。

通过

ACK，Seq=ISN_client+1，ACK=ISN_server+1

SEQ 表示请求序列号，ACK 是确认序列号，SYN 和 ACK 为标志位。

发送首个SYN的一方被认为是主动打开的一个连接，也就是客户端。

### TCP断开连接

当客户端和服务端不再进行通信时，都会以4次挥手的方式结束连接。连接任何一方都能够发起一个关闭操作，还支持双方同时关闭连接的操作。大部分都是客户端发起连接关闭，下面把主动发起关闭的一段当作客户端。两次FIN，两次确认。

1. 客户端向服务端发送断开TCP连接请求的 [FIN,ACK,SEQ] 报文，在报文中随机生成一个序列号 SEQ=K，表示**要断开TCP连接**。ACK用于确认对方最近一次发来的数据L。

2. 服务端收到客户端发来的断开TCP连接请求后，回复发送 ACK=k+1报文确认收到请求，SEQ=L，**表示收到断开请求**，回复的是客户端请求。

   这将导致app 发起自己的关闭操作，**被动关闭身份转变为主动关闭，发送自己的FIN**，序列号SEQ为L， ACK = k + 1。

3. 服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开。服务端会先确认断开前，所有传输到客户端的数据是否已经传输完毕，**确认数据传输 完毕后才进行断开**，向客户端发送 [FIN,ACK] 报文，设置字段值为1。再次随机生成一个序列号 SEQ = z。由于还是对客户端发来的 TCP 断开请求序列号 SEQ = x 进行回复，因此 ACK 依然为 x + 1。

4. 客户端收到服务器发来的TCP断开连接数据包后将进行回复，表示收到断开 TCP 连接数据包。向服务器发送ACK报文，**确认FIN报文**，序列号 SEQ = k。回复的是服务器，ACK 字段的值在服务器发来断开TCP连接请求序列号 SEQ = L的基础上加1，得到 ACK = L +1。

### TCP半关闭

TCP协议还支持连接处于**半开启状态**，这种情况并不常见。存在半开启状态的原因在于TCP的通信模型是双向的。这也意味着**在两个方向中可能会出现只有一个方向正在进行数据传输的情况。**

**TCP的半关闭操作是指仅关闭数据流的一个传输方向**，而两个半关闭操作合在一起就能够关闭整个连接。因此TCP协议规定通信的任何一方在完成数据发送任务后都能够发送一个FIN。当通信的另一方己收到这个FIN时，就会告知应用程序对方已经终止了对应方向的数据传输。当程序发布关闭操作请求后**，通信双方往往通过发送FIN段来关闭双向的数据传输。**

**半关闭就是，我已经完成了数据传输，并发送了一个FIN给对方，但是我仍然希望接受来自对方的数据，知道它发送一个FIN给我。**

1. 发起半关闭的一方，发送FIN字段，接受方接收到，进行ACK确认。
2. 接受方可以继续发送任意数量的数据段
3. 接受方完成了数据传输后，发送一个FIN来关闭本方的连接，同时向发起半关闭的应用程序发出一个文件尾指示，第二个FIN被确认，整个连接完全关闭。

### 同时打开与关闭

在特定安排情况下，有可能两个应用程序同时主动打开连接。通信双方在接受到对方的SYN之前必须先发送一个SYN，两个SYN必须经过网络送达对方。该场景还要求通信双方都拥有一个IP地址和端口号，并且将其告知对方。

这种情况下，服务器始终是连接的被动打开者，而非主动打开者，各自的客户端也会选择不同的端口号。因此，可以被区分为两个不同的TCP连接。

一个同时打开的过程需要交换4个报文段，比普通的三次握手增加了一个。由于通信双方都扮演了客户端与服务端的角色，因此不能够将任何一方称作客户端活服务端。数据包的SYN位将置位直到接收到一个ACK数据包为止，两个SYN，两个ACK。

同时关闭与正常关闭相似，只是报文段的顺序是交叉的。

### 初始序列号

当一个连接打开时，任何拥有合适的IP地址、端口号、符合逻辑的序列号(窗口中)以及正确校验和的报文段都将被对方接收。在连接中，TCP报文段在经过网络路由后可能会存在**延迟抵达与排序混乱**的情况。这个问题需要仔细选择初始版本号。

在发送用于建立连接的SYN之前，通信双方会选择一个初始序列号。初始序列号会随时间而改变，因此每一个连接都拥有不同的初始序列号。**初始序列号可以被看作一个32位的计数器，每4微秒加1，为了在一个连接的报文段安排序列号，防止出现与其他连接的序列号重叠**。尤其对于同一连接的两个不同实例而言，新的序列号不能出现重叠的情况。

由于序列号连接是被一对端点所唯一标识的，其中包括2个IP地址和2个端口号构成的4元组，因此即便是同一个连接也会出现不同的实例。如果**由于连接延迟的报文段的长时间延迟被关闭，然后又以相同的4元组被重新打开，延迟的报文又被视为有效数据重新进入新连接的数据流中**。一个对数据完整性有较高要求的应用程序也可以在应用曾利用CRC或校验和保证数据在传输过程中没有出现任何错误。

一个TCP报文只有同时具备连接的4元组与当前活动窗口的序列号，才会在通信过程中被认为是正确的。也在侧面反映了**TCP的脆弱性**：如果选择合适的序列号、IP地址以及端口号，任何一个人都能伪造出一个TCP报文段，从而打断了TCP的正常连接。一种抵御上述行为的方法是使初始序列号(或者临时端口号)使变得相对难以被猜出，而另一种方法则是加密。

### 初始序列号实现

现代系统通常采用半随机的方法选择初始序列号，Linux 系统采用了一个相对复杂的过程来选择它的初始话序列号。

Linux 采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量。随机偏移量是在连接标识(4元组)的基础上利用加密散列函数得到的。散列函数的输入每隔5分钟就会改变一次。在32位的初始序列号中，最高的8位是一个保密的序列号，而剩余的各位则由散列函数生成。

Windows 系统采用了一种基于RC4的类似方案。


---
title: "TCP超时和重传"
date: 2021-10-21T22:32:49+08:00
draft: true
toc: true
images:
tags: 
  - TCP
---

TCP 的可靠性，在下层网络(IP) 出现丢失、重复、乱序的时候，会重传认为已经丢失的包。

当数据短或确认消息丢失，TCP启动重传操作，重传尚未确认的包，基于时间、确认消息的两套机制。

**每次重传间隔时间加倍称为二进制指数退避（binary exponential backoff**

- **RTO** Retransmission TimeOut，重传超时（计时器超时）

  TCP 在发送数据的时候会有一个定时器，若到计时器超时仍未收到数据确认消息，会引发相应的超时或基于计时器的重传操作。

- 快速重传

  没有延时的情况，TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认消息(SACK)表明出现失序报文段时，快速重传会推断出现丢包。发送端认为接收端可能出现数据丢失时，需要决定发送新数据还是重传。

## R1、R2

TCP拥有两个阈值来决定如果重传同一个报文段【主机需求RFC1122】

- R1 表示TCP在向IP层传递 【消极建议】(重新评估当前的IP路径) 前愿意尝试重传的次数/等待时间
- R2  > R1,指示TCP应放弃当前连接的时机。

R1，R2 应分别至少设为三次重传和100秒，对连接的建立过程(发送SYN报文段)，阈值设置与数据段传输有所区别，针对SYN报文段的R2应最少设置3分钟。

Linux 中，R1,R2 可以通过应用程序、系统配置变量设置

- net.ipv4.tcp_retries1 net.ipv4_tcp_retries2 设置，变量值为重传次数。
- tcp_retries1 默认为3
- tcp_retries2 默认值为 15次，时间根据具体的RTO而定。
- 对于 SYN 报文段，net.ipv4.tcp_syn_retries 和 net.ipv4.tcp_synack_retries 限定重传次数，默认为5，约180秒。

## RTT设置RTO

网络状态的变化，导致 RTT（Round-Trip Time）也在动态变化，RTO 先于RTT 开始会引起不必要的重传，在RTT之后开始会使得整体网络的利用率降低。RTT 的测量本身也比较复杂，**TCP跟踪这些变化适时做出调整来维持好的性能**。

RTO 设置得当是保证TCP性能的关键，**TCP 收集一段时间内 RTT样本值，建立好估计值**，RTT 样本通过 **收到数据后返回的确认消息中携带一个字节的数据(特殊序列号)来测量改确认消息所需的时间。**

**每个TCP连接的 RTT 独立估算，重传计时器会对任何占用序列号的再传数据(包含SYN和FIN报文段)计时。**

## 经典测量方法

最初 RFC0793 的平滑 RTT 估计值为

> **SRTT  <--- ∂ (SRTT) + (1-∂) RTTs**

 SRTT **根据现有的样本和新样本(RTTs) 得到更新结果**，∂ 为平滑因子，推荐值为 0.8 ~ 0.9。

每当得到新的样本值，SRTT 就会做出相应的更新，**新的估计值大概率取决于现存值**，这种算法成为 **指数加权移动平均(Exponentially Weighted Moving Average，EWMA) 或低通过滤器(low-pass filter)**，实现比较简单。

上面的公式目前最新的网络状态表现不明显，RFC0793推荐新的公式：

> **RTO = min（ubound，max（lbound，（SRTT）ß））**

ß 为时延离散因子，推荐值为 1.3 ～ 2.0，ubound 为RTO的上边界(可以设定)，lbound 为 RTO 的下边界(可设定)，该经典方法，使得 RTO 为 1 秒，约两倍的 SRTT，对于**相对稳定的RTT分**布来说，这种方法性能不错。

上述经典方法通过设置上下边界固定后，出现**大规模的变动**，特别是**实际的 RTT 远大于估计值时，会导致不必要的重传，进一步加重网络的负担**。**可以通过RTT样本的均值、记录RTT样本的变化情况来设置 RTO**，相对于仅仅使用均值的常数倍来计算RTO 更能适应RTT变化幅度较大的场景。

## 标准方法（太难了）

## 时钟粒度和RTO边界

测量RTT的过程中，TCP的时钟始终运转，没有绝对的精度，并非从零开始计时，通常为某个变量，该变量的值随着系统时钟做出更新(并非同步更新)，TCP时钟的一次[滴答]时间长度称为粒度，粒度会影响RTT的测量以及RTO的设置，粒度用于优化RTO的更新情况，同时给RTO设置了一个下边界。

> **RTO = max（srtt  + max（G，4(rttvar)，1000）**

G 为计时器粒度，**1000ms 为整个 RTO 的下边界(RFC6298的建议值)**，可以看出RTO 至少为1s，同时提供了可选的上边界。

sett 为均值的 EWMA，sttvar 为绝对误差的 |Err| 的 EWMA，这个就算了。

## RTO初始值

在首个SYN交换前，TCP无法设置 RTO的初始值，除非系统提供（转发表缓存），否则无法设置估计器的初始值，RFC6298 设置RTO的初始值为1s，初始SYN报文段采用的超时时间间隔为 3s。

当收到首个 RTT 测量结果M，估计器按照以下方式初始化：

> **srtt  <-- M**
>
> **rttvar <-- M/2**

## 重传二义性

在测量RTT过程中出现重传，收到的确认消息是对于那一次的确认存在二义性，此时不能确定更新RTT估计值，需要通过排除二义性来解决RTT估算中出现的二义性问题。

RFC6298 要求：

- 设置RTO过程中完全忽略重传问题，可能将网络提供的一些有用信息同时忽略
- 网络不再出现丢包前降低重传率有助于减轻网络负担

就是排除了对第一次的确认，增大了RTO。

TCP 在计算 RTO 过程中采用了一个**退避系数(backoff factor)**，每当重传计时器出现超时，退避系数加倍，一直持续到接收非重传数据。退避系数重新重新设置为1，重传计时器返回正常值。

**TCP超时会引发拥塞控制，发送速率也会被改变。**

## Karn 算法

**当接受到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题。但是如果长时间内都是超时重传，RTO不能够更新，会有大量的重传发生，这个时候可以用二进指数制退避(binart exponential backoff)每重传一次，就把RTO增大。**

对该数据之后的包采取退避策略，收到没有重传的数据时，退避系数重置，SRTT 才用于计算 RTO。

**带有时间戳选项的情况，可以比避免确认的二义性。**

## 带有时间戳选项的RTT测量

时间戳选项允许发送者在返回的对应确认消息中携带一个32比特的数，时间戳值携带于初始SYN的TSOPT中，并在 SYN+ACK的TSOPT的TSER部分返回，以此设定 srtt、rttvar 和 RTO的初始值。由于初始SYN可看作数据，应测量其RTT值，结合其他报文段的TSOPT，估算该连接的RTT。

由于**TCP不是对收到的每个报文段都返回ACK**，**当大量数据传输时，TCP通常采取每两个报文段返回一个ACK的方法**，当数据出现丢失时、失序或重传成功时，**TCP的累积确认机制表明与其 ACK之间并非严格的一对一对应关系**。

## 携带TSV的测量过程

1. TCP发送者在其发送的每个报文段的TSOPT的TSV部分携带一个32bit的时间戳值，包含发送时刻的TCP时钟值。
2. 接收端记录接收到的TSV（TsRecent）并在对应的ACK中返回，并且记录其上一个发送的ACK号（LastACK），ACK 代表接收端期望收到的下一个序号。
3. 当一个新的报文段到达，如果其序列号与 LastACK 的值一致，将其TSV存入TsRecent。
4. 接收端发送的任何一个ACK都包含TSOPT，TsRecent 变量包含的时间戳值被写入其 TSER 部分。
5. 发送端接收到ACK后，将当前TCP时钟减去TSER值，得到的差就是新的 RTT样本估计值。

FreeBSD、Linux 以及 Windows 都默认启用了时间戳选项，Linux  配置 net.ipv4.tcp_timestamps 控制是否使用该选项(0 禁用,1使用)。

## Linux 的 RTT

最小RTO 可以更改，需要改变内核配置常量 TCP_RTO_MIN的值。

TCP 对不含数据的报文段不提供可靠性传输，意味着若出现丢包不会重传，因此无需设定重传计时器。

TCP 选项本省并不进行重传货可靠传输，尽当数据段（包含SYN和FIN报文段）中明确规定，才会丢失重传。

## 基于计时器的重传

一旦TCP发送端得到了基于时间的变的RTT测量值，就能根据设置RTO，发送报文段时应确保重传计时器设置合理。

**设置计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的ACK，那么计时器被取消。**

之后发送端发送一个新的数据包时，需要设定一个新的计时器，并记录新的序列号。

因此每一个TCP连接的发送端不断的设定和取消一个重传计时器，如果没有数据丢失，就不会出现计时器超时。

**设置的RTO时间内没有收到被计时报文段的ACK，将会触发超时重传，TCP会降低当前数据的发送率来进行快速响应。**

- **基于拥塞控制机制减小发送窗口大小**
- **当一个重传报文段被再次重传时，增大RTO的退避因子(Karn)**

当同一个报文段出现多次重传时，RTO值暂时性的乘上值 y 来形成新的超时退避值 RTO = y RTO。

通常 y = 1, 随着多次重传，y 加倍增长，y 不能超过最大退避因子，linux 设置  RTO 不能超过 TCP_RTO_MAX，默认值为 20s，一旦收到 响应的ACK，y会重置为1。

大多数情况，计时器超时并触发重传是不必要的，因为RTO的设置通常大于RTT，**基于定时器的重传会导致网络利用率下**降，同时需要对每一个连接的每一个报文段设置，取消定时器。

## 快速重传

**快速重传机制**[RFC5681] **基于接收端的反馈信息来引发重传**，相比基于计时器的重传能够更加有效的修复丢包情况。

**当接收到失序报文段时，TCP需要立即生成确认信息（重复ACK），不能延迟发送，这个时候接收端缓存出现了空缺，发送端需要尽快的填补空缺。**

**重复ACK（**不管是否包含SACK）到达发送端表明先前发送的某个分组已丢失，**接收端没有收到期望的序列号报文段时**，本来期望到达的报文段可能丢失也可能是延迟到达，**不能确定是延迟还是丢失**，**TCP会等待一定数目的重复ACK（重复ACK阈值或 dupthresh）来决定数据是否丢失并触发快速重传。通常 dupthresh 为常量(3)，但一些非标准化的实现可以基于当前的失序程度来动态调节 dupthresh**。

TCP发送端收到至少 dupthresh 个重复ACK后，重传可能丢失的数据分组，不必等到重传计时器超时，重复ACK通常和网络拥塞有关，**快速重传应该出发拥塞控制机制**。

不采用SACK 时，接收到有效ACK前至多只能重传一个报文段，采用SACK，ACK可以包含额外信息，使得发送端在每个RTT时间内可以填补多个空缺。

## 报文段丢失时的 SACK

接收端在TCP连接建立期间收到SACK许可选项就可以生成SACK，每当缓存中收到了失序数据时，接收端就可以生成SACK。

SACK 块内包含的是最近收到的报文段序列号，后面的SACK 会重复之前的块信息，防止丢失做了备份。如果SACK不会丢失，每个SACK包含一个SACK块就可以实现SACK的全部功能，但**是SACK和普通的ACK会丢失，如果其中不包含数据(SYN或FIN控制位字段不被置位)就不会被重传。**

发送端记录接收到的ACK信息，还要记录接收到的SACK信息，避免重传正确接收到的数据。当接收到相应序列号范围的ACK时，在其重传缓存中标记接收到响应的ACK选择重传成功。

## SACK对上行网络带宽的影响

SACK 主要是接收端告知发送端自己缓冲区里面的缺失空洞，主要是携带失序/空缺的报文序列段范围，公共前缀和左边界、右边界组成失序的报文序列段范围，大部分场景下，拥塞窗口较小，**边界描述占用没有达到那么大的空间，SACK 大小的存在对上行网络带宽的浪费**。

## 接收端SACK的变更

**SACK选项和SACK是建议性的，接收端可能会做出变更**，可能上一个SACK块告知没有报文段缺失，下一个SACK块告知有缺失，因此**发送端不能立即清空其重传缓存中的数据，只有当接收端的普通ACK号大于其最大序列号值时才可清除**。

这种接收端的SACK变更也会影响重传计时器超时，如果启用了基于计时器的重传，应该忽略SACK显示的任何关于接收端数据失序的信息，如果仍然存在失序数据，重传报文段的ACK中就包含附加的SACK块。

------

**发送端采用SACK并不能百分百的提高整体性能，RTT较大，丢包严重的场景，SACK能够在RTT内填补多个空缺才能够提供性能。**

## 伪超时和重传

伪重传（Spurious retransmission）没有出现丢失引起不必要重传，主要是由**伪超时（spurious timeout），过早判定超时**、包失序、包重复、ACK丢失等原因导致。**在实际RTT显著增长，超过当前RTO时，可能会出现伪超时**。

处理伪超时问题，包含**检测算法和响应算法**。

detection 用于判断某个超时或基于计时器的超时的重传是否真实，一旦认定出现伪超时则执行 response 算法，用于撤销或减轻该超时带来的影响。

## 回退N行为

go-back-N，延迟ACK，发送端判定超时，会连带没有收到ACK相邻的报文重发，会导致多个已经ACK过的包，再次重传。

## DSACK(接收端)

没有启动SACK的连接中，**ACK只能告知发送端最大的有序报文段，SACK能够告知发送端失序的报文段**，**SACK机制没有规定收到重复的数据段怎么应对**，重复的数据可能是伪重传、网络的重复造成的。

在SACK**接收端采用了DSACK**（D-SACK，重复SACK），结合通常的SACK发送端，**可以在第一个SACK块中告知接收端收到的重复报文段序列号**。

DSACK 的主要目的是**判断何时的重传是不必要的**，并了解网络中的其他事项，这样可以**让发送端推断是否发生了包失序、ACK丢失、包重复或伪重传**。

**一个非DSACK与DSACK的TCP共用一个连接，他们会交互操作，非DSACK不能使用DSACK的功能。**

**接收端允许包含序列号小于等于累积ACK号字段的SACK块**，DSACK 信息之宝在单个ACK中，不会在多个SACK中重复，鲁棒性较低。

## Eifel detection

**利用 TSOPT 来检测伪重传，超时重传时，保存 TSV，等待ACK，比对 ACK 的 TSER，如果 TSER  小于 重传的 TSV ，则表明这次重传为伪重传，因为 等待到的ACK 是对之前的发送的报文段的确认。**

**Eifel 能比仅采用 DSACK更早的检测到伪重传行为，？？？这个不太能够吧，只有第一次ACK延时回来，并且在第二次重传的ACK回来之前回来，这个时候发送端才能检测到第二次重传是伪重传的。**

及早检测伪重传是有利的，能是避免回退N行为，但是ACK丢失这个没办法的，只能重传。

EiFel 搭配 DSACK 使用，可以解决整个窗口的ACK信息都丢失，DSACK的到达能够使得 EiFel 认定相应的重传不是伪重传。

## F-RTO

Forward-RTO Recovery，F-RTO，前移RTO恢复，是检测伪重传的标准算法，**不需要对TCP任何选项，只要在发送端实现方法就行**，**只检测由重传计时器超时引起的伪重传。**

计时器重传之后，F-RTO 会对TCP的常用行为做出一定的修改，**由于这类重传针对的是没有收到ACK信息的最小序列号，通常情况下，TCP会继续按序发送相邻的分组，也就是会退N行为。**

F-RTO 会修改TCP的行为，在超时重传后收到第一个ACK时，TCP会发送新的数据（非重传），之后在响应后一个到达的ACK，如果其中一个为重复的ACK，则认为此次重传没问题，如果两个都不是重复ACK，则表示该重传是伪重传。
?????那就是一个ACK超时返回，两次都收到了，不就是超时了一个吗，重传的是伪重传，但是又和超时机制冲突了。


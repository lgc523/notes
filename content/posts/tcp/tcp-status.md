---
title: "TCP状态转换"
date: 2021-09-22T23:12:55+08:00
draft: true
toc: true
images:
tags: 
  - tcp
---

## TIME_WAIT

TIME_WAIT 状态也称为2MSL等待状态，该状态中，**TCP会等待两倍于最大段生存期(Maximum Segment Lifetime，MSL)的时间**，有时也被称作加倍等待。每个实现都必须为最大段生存期选择一个数值，代表**任何报文段在被丢弃前在网络中被允许存在的最长时间**。

**由于TCP数据报被IP数据包承载，IP数据报TTL字段和跳数限制字段又限制了IP数据报的有效生存时间。**

RFC 将最大段的生存期设为2分钟，最大段的生存期的数值可以为 30s、1分钟或者2分钟。

Linux 可以修改 net.ipv4.tcp_fin_timeout 数值记录了 2MSL 状态需要等待的超时时间(以秒为单位)。

如果已经设置了MSL的数值，当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT 状态并持续两倍于最大生存期的时间。这样就**能够让TCP重新发送最终的ACK以避免出现丢失的情况**。重发最终的ACK不是因为TCP重传了ACK，而是因为通信的另一方重传了它的FIN。TCP总是重传FIN，直到它收到一个最终的ACK。

当TCP处于等待状态时，通信双方将该连接(四元组)定义为**不可重新使用**。只有2MSL等待结束时，或一条新连接使用的初始序列号超过了连接之前的实例所使用的最高序列号时，或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时，这条连接才能被再次使用。

有些系统实现，如果一个端口号被处于2MSL等待状态的任何通信段所用，那么该端口号将不能再次使用。 但有些实现API都绕开了这个约束，及时2MSL 等待占用了端口号，还会分配本地端口号。

### 防止端口号被打开

TCP 还是会**防止端口号被处于2MSL等待状态的同一连接的其他实例重新打开**。当一个连接处于2MSL等待状态时，任何延迟到达的报文段都将被丢弃。一个连接是通过地址和端口号的5元组定义的。如果该连接处于2MSL等待状态，那么在这段时间内将不能被重新使用，当这条正确的连接信息最终被建立起来后，这条连接之前的实例所传输的延迟报文段是不能被当作新连接的一部分来解读的。

### 客户端2MSL

通常客户端主动发起关闭，并进入 TIME_WAIT 状态，服务器通常执行被动关闭操作而且不会直接进入 TIME_WAIT 状态。关闭一个客户端再重新启动，通常OS会分配临时的端口号，实际上是出于安全考虑推荐的随机方法[RFC6056]。**客户端能够快速产生大量的连接(尤其是同一个客户端)，不得不再临时端口号供应紧张时延迟一会儿来等待其他连接的终止。**

### 服务端2MSL

对于服务端，如果终止一个已经建立了一条连接的服务器进程，然后立即尝试重新启动它，服务器不能为该程序的通信端分配对应的端口号(地址已经占用了)，这是**因为当连接进入2MSL 时，端口号仍然是连接的一部分**。

## 静默时间

在本地与外部ip地址、端口号都相同的情况下，**2MSL 状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据的状况**，只有在与处于2MSL等待状态的连接相关的主机未关闭的条件下才具有意义。

如果一台与处于TIME_WAIT状态下的连接相关联的主机崩溃，然后在**MSL内重启**，使用与主机崩溃之前处于TIME_WAIT 状态的连接相同的IP地址与端口号，这个时候，**该连接在主机崩溃之前产生的延迟报文段会被认为属于主机重启的后创建的新连接**，这种处理方式将不会考虑在主机重启之后新连接是如何选择初始序列号的。

为了防止MSL内重启延迟报文混淆，RFC0793 指出**在崩溃或者重启后 TCP 协议应当在创建的连接之前等待相当于一个MSL的时间**。该段时间被称为静默时间。只有极少数遵循了这一点，因为绝大多数的主机在崩溃之后都需要超过一个MSL的时间才能重新启动。

## FIIN_WAIT_2状态

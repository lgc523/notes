---
title: "Mark Sweep GC"
date: 2021-11-15T23:10:47+08:00
draft: true
toc: true
images:
tags: 
  - gc
---

标记清楚算法由标记阶段和清除阶段

- 标记阶段把所有活动对象打上标记
- 清除阶段把没有标记的对象回收

## mark phase

1. 首先标记根直接引用的对象（在内存中存活的对象）
2. 递归地标记记通过指针数组能访问到的对象，避免重复标记

标记未完成，会对活动对象的头部进行置位操作，这个位分配在对象的头中，能够通过对象访问，标识对象是否已经标记。

标记话费时间和内存中活动对象总数成正比，过程就是从根遍历打标记。

## DFS BFS

搜索对象并进行标记时使用 DFS/BFS，搜索的步数不会有差别，内存使用量上DFS 更能压低内存使用量，在树变高的情况更明显

？ 这块是局部性导致的吗 ？

## sweep phase

清除阶段，会遍历整个堆，回收没有打上标记的对象。

对象头上的 size 域，标识对象存储信息。

- **清除从堆的首地址开始，按照顺序遍历一个个对象的标志位，设置了标志位，表明对象时活动对象，取消标志位，准备下一次GC，下一次GC，会先在标记一次，再来清除**。
- 回收对象就是**把对象作为分块，连接到被称为空闲链表的单向链表的头**，之后分配通过遍历链表进行。
- 回收修改了当前对象的 next 域，连接单向链表，对象已死，重写域没有问题。

同样，堆越大，清除阶段耗时越久。

## allocation

分配：mutator 申请分块时，搜索空闲链表寻找大小合适的分块，分配给 mutator。

### First-fit

- 找到相同的分块大小直接返回
- 找到大的分块会将其分割，剩余分块返回空闲链表，剩余的分块可能会一直不满足申请分块需求，会一直占用前面的位置
- 没有找到合适的分块，返回 NULL

### Best-fit

遍历链表，返回大于等于申请大小的最小分块

### Worst-fit

找到最大分块将其分割，将剩余分块最大化，容易产生大量小分块

## coalescing

分配策略可能会产生大量的小分块，如果他们是连续的，就能把所有的小分块连接在一起形成一个大分块，**连接连续分块的操作成为合并，合并在清除阶段进行**。

## advantage

- 实现简单，与其他算法组合也相应简单
- 与保守式GC算法兼容 (对象不能移动)

## deficiency

**fragmentation**：**会逐渐产生被细化的分块，导致无数的小分块散布在堆的各处，增加 mutator 负担（访问时间）**。

## allocation speed

**分块不连续，每次分配都必须遍历空闲链表，找到足够大的分块，最快情况每次都遍历到单向链表到最后。**

## not-compatible COW

Copy on write 主要是通过 lazy copy ，多用在共享内存读多写少的场景， 涉及到 MMU、虚拟内存映射、页面调度。

在需要对共享内存空间（read_only）写入时，不直接重写共享内存，避免数据不一致，先复制自己私有空间的数据，对私有空间进行重写。复制后只访问这个私有空间，不访问共享内存，在写入时复制。

mark sweep 两个阶段设置取消标志位，都会重写对象，频繁发生不应该的复制，进而压迫内存空间，为了处理这个问题，采用 bitmap marking 标记，bitmap 对字节的一个bit 通过map 进行映射，只是为了减少 copy 的消耗。

## multi listNode

单个单向链表存储空闲的分块，大小不同的分块在申请的时候寻找合适的分块比较浪费时间，利用多个空闲链表可以加速合适分块的寻找，但是维护空闲链表数组的数量太大也会压迫到内存空间，并且数组空间是连续的，比较占用堆内存的利用率。

通常会给分块大小设定一个上限，如果大于等于阈值，全部采用一个空闲链表处理，有点有限负载隔离的意思。

## BiBOP

**Big Bag Of Pages** ：**将大小相近的对象整理成固定大小的块进行管理，将堆分割成固定大小的块，每个块只能配置同样大小的对象。**

相当于提前分配好存放固定大小块链表的数组，这样使得单个块的利用率得到了提高，一定程度的减少了碎片化，但是堆内存的利用率并不高，必要的时候还需要扩缩容操作。

## bitmap mark

- 标记阶段

  **收集对象的标志位并表格化，不和对象一起管理**，标记阶段在**位图表格**的映射位置置位，利用 bitmap table 来进行 mark。

  其实就是降低 COW lazy write 的开销，COW 的影响还是有的，如果堆内存很大，bitmap 也会被放大。

- 清除阶段

  之前清除阶段需要遍历整个堆，把非活动对象链接到空闲链表，同时取消活动对象的标志位。

  利用 bitmap，清除遍历堆的同时遍历 bitmap，这个时候，**如果设置了标志位，不会消除bitmap 上的位，放到之后一并进行**。

- 多个堆

  存在多个堆的情况，单纯的位运算进行地址映射比较困难，通常构建多个 bitmap table。

## Lazy Sweep

Mark Sweep 两个阶段都是遍历全部的堆内对象，堆越大，STW 越长，进一步妨碍 mutator 的处理。

标记阶段是必须进行的，清理阶段大部分不是必须的，满足了当下的分配需求可以在进行清除，通过延迟清除可以减少因为清除操作导致的 mutator 最大暂停时间。

**分配时直接调用 lazy_sweep，进行消除操作**

- 如果能够通过清除来分配，就返回分块
- 不能分配，返回 NULL，就执行标记操作，在调用 lazy_sweep 分配，还没分配成功， mutator 就 hang 住 ？？？

相当于每次从头全量遍历寻找合适的分块， lazy_sweep 通过全局的遍历偏移来减少遍历的时间，但是单向遍历有可能就刚好错过了，如果可以双向遍历是不是好一点，结合多级的空闲链表数组，其实遍历的 round time 也很小了。

极端情况，活动对象和非活动对象在堆内存中形成了两个相邻的分区，在清除活动对象附近时，会增加 mutator 的一次等待，并且可能会周期性的出现。

## Q

1. 会不会出现内存抖动，什么是内存抖动，内存抖动会影响什么
2. 能不能像 java TLAB 对对象的分配进行有限的负载控制，让到堆上的对象进行均衡
3. 逃逸的问题

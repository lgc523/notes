---
title: "Reference Counting"
date: 2021-11-16T21:53:06+08:00
draft: true
toc: true
images:
tags: 
  - gc
---

GC本来就是一种释放怎么都无法被引用的对象的机制，1960 年George E·Collins 提出。

## count

计数器是无符号的整数，用于计数的位数根据算法和实现有所不同，在mutator 的处理过程中通过增减计数器的值来进行内存管理。

**引用计数法中，除了链接到空闲链表的对象，其他所有对象都是活动对象。**

```
[ 计数器 |   域   ]
```

## newObj

生成新对象，分配到合适的分块后，如果对象被某处引用了，把计数器的值定为1。

## updateObj

更新指针指向，会进行计数器值的增减。

- 先对指针新引用对象的计数器进行增量操作
- 再对指针之前引用的对象的计数器进行减量操作，之后会变成垃圾链接到空闲链表，并遍历其子对象进行减量操作

**先增后减的步骤，为了避免更新的引用是同一个对象，先减可能会使得对象被回收。**

引用计数算法会立刻回收垃圾，在分配没有分块的情况下，堆中所有的对象都为活动对象，就没办法进行分配对象，而标记清除算法会在没有合适分块的时候一块清除。

## advantage

- **可即刻回收** 

  对象始终知道自己的引用计数，被引用数的值为0时，对象马上就把自己作为空闲空间连接到空闲链表，堆空间中不会有垃圾占用。

- **STW 短**

  引用计数只有当通过 mutator 更新指针时程序才会执行垃圾回收，每次通过执行 mutator 生成垃圾时都会被回收，大幅度消减了 mutator 的最大暂停时间。

  **相当于标记清除，对 mutator 来说是两步合一步。**

- **没有必要沿指针查找**

  不用关心对象间的相互引用来判别是否存活

### Q

1. 立即回收是怎么做到的，trigger 还是 callBack
2. 立即回收可能会存在 race 

## deficiency

- **计数器值的增减处理繁重，特别是有根的指针，eg:栈空间递归**

- **计数器本身占位**

  根据计算机的位不同，内存能够 load 的对象越多，计数器的最大值就越大，各种引用的增加都需要计数器的位足够大。

- **实现繁琐**

  书上说，更新对象的引用，要将以往 直接引用的改成两步增减操作，重写容易出现遗漏，产生bug

  **没看太懂，在我看来 GC 作为 语言处理程序，应该是类似 MySQL 引擎一样的插件形式工作。**

- **循环引用无法回收**

  两个及两个以上的对象互相循环引用形成对象组的情况，即使对象没有被真正的引用，GC程序无法将其回收。

## Deferred Reference Counting

从根的变化引用变化频繁，会导致计数器值的增减处理繁重，比如 递归、全局变量、循环

既然繁重，L·Peter Deutsh 和 Daniel G· BoBrow  就放弃了**从根引用的指针更新引用维护计数器的操作**。

**引用的更新没有反映到计数器上，可能会被误判当成垃圾回收**（这个延迟不是全局的，只是从根引用的对象）。

## ZCT

Zero Count Table，通过一个表，记录计数器变成 0 的对象，这些对象都是从根出发引用的，计数器值为零，但是不一定都是垃圾，通过ZCT 保留。

## newObj

分配时，如果无法从空闲链表分配到合适的分块，就先搜索一遍 ZCT，再次分配，如果不行分配失败。

## scan_zct

1. **无法分配 / ZCT 占满，搜索ZCT**，会把所有通过根直接引用的对象的计数器都进行增量，把根引用反应到计数器数值上。
2. **调查与 ZCT 相连的对象，如果存在计数器为 0 的对象，则将此对象从 ZCT 删除**
   1. **对该对象的子对象的计数器进行减量操作**
   2. **回收该对象，连接到空闲链表**

### Q

满足从 ZCT 删除对象的计数器变化

1. 计数器减到 0 加入 ZCT
2. 首次无法分配，扫描 ZCT ，这个时候 ZCT 上对象的计数器都是 0。
3. 扫描 ZCT 先循环一遍，将所有的对象计数器 + 1，现在等于 1。
4. 再次循环，调查每一个对象，如果存在计数器值为 0，将其删除。
5. 最后循环将对象的引用子对象计数 -1，将该对象链接到空闲链表。

第四步删除，是因为该对象真正的没有被引用，也就是有一部分计数器增加操作被忽略，使得计数器置为0 被提前。

在扫描的过程中，在第一次循环计数器 + 1，和第二次循环遍历到该对象的时间节点中，至少有一个引用该对象的对象引用被修改或者被回收。

。。。

从根出发的对象，只有 全局变量空间、栈、寄存器，唯一合理的解释就是，在这一段时间内 栈弹出/执行结束，并且后面没有被传递下去，该对象不属于从根引用的对象。



抛开编译器的编译器、运行期优化，代码的质量是会影响对象分配的，另外 **ZCT 的大小直接影响遍历的效率，减小 ZCT 的大小，ZCT 的扫描操作会变得频繁，进而又会降低吞吐量**，显然一个长时间的循环/递归，维护计数器的压力是巨大的。

延迟计数器的增减，垃圾不能马上回收，垃圾就会压迫堆内存空间，这个 trade off 让我难受的窒息。

## Sticky


---
title: "Garbage Collection"
date: 2021-11-15T21:57:17+08:00
draft: true
toc: true
images:
tags: 
  - gc
---

1960年，McCarthy 在其论文中首次发布了GC算法，标记清除算法，Mark Sweep GC。

GC要做的事情

- 找到内存中的垃圾
- 回收垃圾，使得内存可以再次利用

## memory leak

内存空间使用完毕后未释放，会发生内存泄漏，我觉得内存漏泄更合适。

## dangling point

释放完内存空间时，忘记初始化指向释放对象的内存空间的指针，这个指针就会一致指着释放完毕的内存空间，因为这个指针没有指向有效的内存空间，处于一种悬挂的状态，称该指针未悬垂指针，如果程序错误引用悬挂指针，就会产生无法预期的bug。

## object

GC里面，对象表示通过APP利用的数据的集合，配置在内存空间里，是GC的基本单元。

### head

**对象中保存对象本身信息的部分，相当于metadata，主要包含对象的大小、种类。**

**根据对象的大小和种类，就可以判别内存存储对象的边界，头中事先存有运行GC需要的信息，不同GC算法信息也不同**。

### Field

对象使用者在对象中可访问的部分称为域，域中的数据类型大致分为 指针、非指针两种。

GC根据对象中的指针指向去搜寻其他对象，对非指针不进行任何操作，这些都以语言处理程序能够判别指针和非指针未前提进行。

## mutator

Edsger Dijkstra，1978年提出的，就是应用程序，可以改变GC对象间的引用关系，GC 在 mutator 内部工作。

进行的操作

- 生成对象
- 更新指针

## heap

堆是用于动态存放对象的内存空间，mutator 申请存放对象时，所需的内存空间就会从堆中分配给 mutator，GC是管理堆中已分配对象的机制。

开始执行 mutator 前，GC 要分配用于堆的内存空间，开始执行 mutator，程序就会按照 mutator 的要求在堆中存放对象，堆被对象占满，就会启动GC，从而分配可用空间。



**内存空间中能够通过 mutator 引用的对象称为活动对象，分配到堆中的不能通过程序引用的对象称为非活动对象。**

**死了的对象不可能活过来，mutator 找不到非活动对象，不能重新引用。**

## allocation

分配是指的是在**内存空间中分配对象**，当 mutator 需要新对象时，就会向分配器 allocator 申请一个大小合适的空间，分配器在堆中寻找满足要求的空间，返回给 mutator。

## chunk

分块是为利用对象而事先准备出来的空间

**初始状态下，堆被一个大的分块占据，程序根据 mutator 的要求把分块分成合适的大小，作为活动对象使用，活动对象变成垃圾被回收，占用的空间再次成为分块等待下次被利用，循环往复。**

## root

根是指向对象的指针起点，能够通过 mutator 直接引用。

全局空间中对象间引用的对象被视为活动的对象，都需要 GC 保护。

- **全局变量空间**
- **调用栈**
- **寄存器**

这些空间都是根，都可以通过 mutator 直接引用，但是 GC 一般情况下无法严谨判断寄存器和调用栈中的值是否为指针。

## evaluation of performance

四个指标评价GC性能

- 吞吐量
- 最大暂停时间 STW
- 堆使用效率
- 访问的局部性

### throughput

单位时间的处理能力，不同算法，需要考虑 mutator 的动作/算法机制，活动对象的数量、极端情况都会影响吞吐量。

### MAX STW

不同的场景，对最大暂停时间的敏感度不一样，有些时间可以等，有些长时间等待会使得程序被用户关闭，需要根据场景 trade off，选举适合的GC算法。

### heap usage

影响堆使用效率的因素：对象头的大小，堆的用法

对象头的大小直接影响堆中能够存放对象的个数，堆中存放的对象越多，GC的效率就越高，吞吐量也高。

不同算法对堆的使用不同，复制算法中将堆等分，交替使用一般，堆的利用率就不高。

### 访问的局部性

通常会把所有的对象放在内存，CPU 访问数据时，仅把要使用的数据从内存读取到缓存，通过内核、预读、页面调度、调用IO设备调度器。。。会把附近的数据都读到缓存中，来压缩读取时间。

通常具有引用关系的对象之间存在连续访问的情况，**把具有关系的对象安排在堆中较近的位置**，能够提高在缓存中读取到想利用的数据概率，从而令 mutator 高速运行。

**复制算法会根据引用关系重排对象**


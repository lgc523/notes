---
title: "Redis Sds"
date: 2022-01-11T00:09:02+08:00
draft: true
toc: true
images:
tags: 
  - redis
---

## simple dynamic string

SDS 用来表示数据库中的字符串值，还被用做缓冲区（AOF缓冲区、客户端状态中的输入缓冲区）。

SDS 结构

- len（4B）buf 已用长度
- alloc (4B)  buf 实际分配长度 
- buf            字节数组

由于结构体中包含字符串的长度，所以获取字符串的长度复杂度为 O(1)。

### SDS空间分配

字符串的修改操作，会导致内存重分配，内存重新分配开销比较大，SDS 实现了**空间预分配**和**惰性空间释放**两种策略来**优化字符串的扩缩容**。

#### 空间预分配

预分配优化 SDS 字符串增长操作，可能会需要进行空间拓展时，额外分配未使用的空间，来减少扩容的内存重分配次数。

- 修改后 len < 1m，预分配和 len 大小相等的未使用空间(alloc = 2len)
- 修改后 len > 1m，预分配 1m 的 未使用空间 (alloc = len + 1m)

#### 惰性释放

惰性空间释放优化字符串缩容操作，修改后 SDS 容量缩小，**不会立即进行内存重分配回收多出来的空间**，而是记录起来，作为未使用空间保留，后续可能还会出现扩容的情况，有一点点 GC 的感觉。

**SDS API 也提供了释放未使用空间的操作来避免内存浪费。**

### binary safe

SDS 结构中的 len 和 buf ，可以不根据 空字符串来判断结束，让 SDS适用于更多的场景（二进制数据）。

### compatibility 

buf 数组空间最后多分配一个字节容纳空字符，让保存文本数据的 SDS可以重用一部分库函数。

Redis 的数据类型有很多，不同数据类型有相同的元数据要记录(最后一次访问的时间，被引用的次数。。。)，使用 RedisObject 结构体来统一记录元数据，同时指向实际数据。

### RedisObject

- 元数据 8B
- ptr 8B 指向具体数据类型的实际数据 -> SDS

## String

### int编码模式

当保存 64 位有符号整数时，String 类型会把它保存为一个 **8 字节**的 Long 类型整数，这个时候 ptr **指针就直接赋值为整数数据**。

当保存的数据中包含字符时，String 类型就会用简单动态字符串结构体来保存。

### embstr编码模式

当保存的是字符串数据，并且字符串 <= 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，来避免内存碎片。

### raw编码模式

当字符串 >= 44 字节时，SDS 的数据量变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起，而是会给 SDS 分配独立的空间，用指针指向 SDS 结构。

当存储整数 pair 时，由于使用的全局哈希表存储所有的键值对，每个键值对存储了 key、value、next 的指针（8B*3=24）,int 编码下，RedisObject 为 (8B+8B) * 2，24+32 = 56 < 64，所以存储整数 pair 占用 64B。

## jemalloc

jemalloc 分配内存时，会根据申请的字节数 N ，找一个比 N 大，但是最接近 N 的 2 次幂最为分配的空间，减少频繁分配的次数。

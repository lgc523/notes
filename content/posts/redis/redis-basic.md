---
title: "Redis Basic"
date: 2022-01-04T21:56:53+08:00
draft: true
toc: true
tags: 
  - redis
---

## Value数据结构

- String
- List
- Hash
- Set
- Sorted Set

## 底层数据结构

- 简单动态字符串
- 双向链表
- 压缩列表
- 哈希表
- 跳表
- 整数数组

## mapping

- String 
  - 简单动态字符串
- List     
  -  双向链表
  - 压缩列表
- Hash
  - 压缩列表
  - 哈希表
- Sorted Set
  - 压缩列表
  - 跳表
- Set
  - 哈希表
  - 整数数组

## 键值对存储结构

redis 使用 哈希表来保存所有的键值对，哈希桶存储指向具体值的指针，对外提供一个很简洁的操作接口 O(1) ，屏蔽了不同的数据类型。

## Hash 散列冲突

**key0  !=  key1，hash(key0) = hash (key1) ，就会放到一个桶的位置，数据量越大哈希冲突的概率就会变大，n -> [0,len(array)]**

### 解决冲突

- 链地址法

  冲突的数据排成链表，头插（新的数据在链表的末尾），链表顺序遍历速度慢，hash 算法不好会退化成链表 O(n)。

  看具体的实现，java hashMap 在桶内数据 > 8 并且数组长度> 64 ，就把链表转化为红黑树，根据 hash 算法的分布概率情况，以及均摊分析后，时间复杂度还是 O(1)。

- 开放地址探测法

  出现冲突，继续找合适的位置。

  - 线性探测法

    直接判断使用下一个空闲单元，步长为1。

  - 平方探测法

    使用公式 冲突单元索引  + 1^2/2^2/3^2... 不是线性查找， 步长较大，一般探测一半就足够了。

  - 双散列函数探测法
  
    使用另外一个散列函数作为步长增量探测，**不太理解**。
  
- 再哈希

  - 同时构造多个不同的哈希函数，发生冲突时用其他哈希函数计算，知道冲突不在产生，不易产生聚集，增加了计算时间。

- 建立公共溢出区

  - 将哈希表氛围公共表和溢出表，溢出发生时，将所有溢出数据统一放到溢出区。

Redis 解决 hash 冲突也是通过链式 hash，不过会做 rehash 操作，通过增加现有的 hash 桶数量，让逐渐增多的元素分散存储，减少单个桶的元素数量，减少单个桶的冲突。

### 两个全局哈希表

Redis 采用了两个全局哈希表，一开始默认使用表1，此时表2 没有被分配空间，随着数据增多，开始 rehash，增加现有桶的数量，让元素能够更分散，减少单个桶的元素数量。

1. 给 表2 分配更大的空间
2. 把表1 中的数据重新映射并拷贝到表2
3. 释放表1 空间

### 渐进式 rehash

Rehash 的过程中表数据迁移会阻塞线程，无法服务其他请求。

Redis 在拷贝数据的时候，每处理一个请求时，从表1中第一个索引位置开始，顺带将这个索引位置上的所有数据拷贝到表2中，等待下一个请求时，在顺带拷贝表1 中的下一个索引位置的数据。

**将迁移的工作量分散到了多次的请求中，避免了长时间迁移导致的不可用，但是会长时间存在两个哈希表。**

**？Golang rehash**

## 集合数据效率

整数数组和双向链表都是顺序读写，时间复杂度为 O(N)，操作效率比较低。

### 压缩列表

压缩列表类似数组，每一个元素都对应保存一个数据，和数组不同的是，表头有三个字段 **zlbytes、zltail、zllen**，分别表示**列表长度**、**列表尾的偏移量**和**列表中的 entry 个数**，**表尾 zlend，表示列表结束**。

基于这样的结构，压缩列表访问第一个和最后一个元素的时间复杂度是 O(1)，访问中间元素的时间复杂度是 O(N)。

### 跳表

跳表结构在链表基础上构建多级索引，有了索引就比大小，跳来跳去定位到元素，减少了链表的顺序寻找次数，当数据量很大的时候，时间复杂度就是 O(logN)。

### 时间复杂度

- 整数数组
- 压缩列表
- 跳表
- 双向列表
- 哈希表 O(1)

### 常见复杂度

- 单元素操作

  - Hash (Hset,Hget,HDel )
  - Set (SADD,SREM,SRANDMEMBER)

  底层数据类型是哈希结构时，对单元素的操作时间复杂度是 O(1)，支持多个参数时，时间复杂度也会随着参数个数增加。

- 范围操作

  - Hash HGETALL

  - Set SMEMBERS

  - List LRANGE

  - ZSet ZRANGE

    这类操作比较耗时，会造成阻塞。

  - SCAN （HSCAN、SSCAN、ZSCAN）渐进式遍历，可以避免阻塞。

  

  ​	





















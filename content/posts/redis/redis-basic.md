---
title: "Redis Basic"
date: 2022-01-04T21:56:53+08:00
draft: true
toc: true
tags: 
  - redis
---

## Value数据结构

- String
- List
- Hash
- Set
- Sorted Set

## 底层数据结构

- 简单动态字符串
- 双向链表
- 压缩列表
- 哈希表
- 跳表
- 整数数组

## mapping

- String 
  - 简单动态字符串
- List     
  -  双向链表
  - 压缩列表
- Hash
  - 压缩列表
  - 哈希表
- Sorted Set
  - 压缩列表
  - 跳表
- Set
  - 哈希表
  - 整数数组

## 键值对存储结构

redis 使用 哈希表来保存所有的键值对，哈希桶存储指向具体值的指针，对外提供一个很简洁的操作接口 O(1) ，屏蔽了不同的数据类型。

## Hash 散列冲突

**key0  !=  key1，hash(key0) = hash (key1) ，就会放到一个桶的位置，数据量越大哈希冲突的概率就会变大，n -> [0,len(array)]**

### 解决冲突

- 链地址法

  冲突的数据排成链表，头插（新的数据在链表的末尾），链表顺序遍历速度慢，hash 算法不好会退化成链表 O(n)。

  看具体的实现，java hashMap 在桶内数据 > 8 并且数组长度> 64 ，就把链表转化为红黑树，根据 hash 算法的分布概率情况，以及均摊分析后，时间复杂度还是 O(1)。

- 开放地址探测法

  出现冲突，继续找合适的位置。

  - 线性探测法

    直接判断使用下一个空闲单元，步长为1。

  - 平方探测法

    使用公式 冲突单元索引  + 1^2/2^2/3^2... 不是线性查找， 步长较大，一般探测一半就足够了。

  - 双散列函数探测法
  
    使用另外一个散列函数作为步长增量探测，**不太理解**。

Redis 解决 hash 冲突也是通过链式 hash，不过会做 rehash 操作，通过增加现有的 hash 桶数量，让逐渐增多的元素分散存储，减少单个桶的元素数量，减少单个桶的冲突。

### 两个全局哈希表

Redis 采用了两个全局哈希表，一开始默认使用表1，此时表2 没有被分配空间，随着数据增多，开始 rehash。

1. 给 表2 分配更大的空间
2. 把表1 中的数据重新映射并拷贝到表2
3. 释放表1 空间

### 渐进式 rehash

Rehash 的过程中表数据迁移会阻塞线程，无法服务其他请求。

Redis 在拷贝数据的时候，每处理一个请求时，从表1中第一个索引位置开始，顺带将这个索引位置上的所有数据拷贝到表2中，等待下一个请求时，在顺带拷贝表1 中的下一个索引位置的数据。

**将迁移的工作量分散到了多次的请求中，避免了长时间迁移导致的不可用，但是会长时间存在两个哈希表。**

**？Golang rehash**

## 集合数据效率






























---
title: "Transaction-2PC,3PC,BASE"
date: 2021-10-17T23:41:03+08:00
draft: true
toc: true
images:
tags: 
  - distributed
  - transaction
---

## 事务

Transaction ，一种机制，将包含一系列操作的工作序列纳入到一个不可分隔的执行单元，只有把操作均被正确执行才能提交事务，任意一个操作失败都会导致整个事务回滚到之前， all or  nothing，想要实现组合指令原子性。

## ACID特征

### Atomicity

事务的最终状态只有 全部执行成功、全部不执行，不会停留在中间的某个环节。

### Consistency

事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。

### Isolation

多个事务并行执行时，使用相同的数据不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。

### Durability

持久性/永久性，一个食物被执行后，对数据库所做的更新就永久保存了下来。

------

**数据操作请求满足上述四个特性，存储系统才能够处于正确的工作状态。**

**分布式下的事务由多个本地事务组成，要满足Consistency，所有操作均执行成功提交结果来保证数据一致性、完整性，但是分布式的规模下要达到强一致性需要时间周期较长，BASE理论指出采用最终一致性来代替强一致性。**

## 实现分布式事务

- 基于XA协议的两阶段提交协议方法(Consistency)
- 三阶段提交协议方法 (Consistency)
- 基于消息的最终一致性方法(BASE)

## 基于XA协议的2PC

**XA是一个分布式事务协议，规定了事务管理器和资源管理器接口，包括事务管理器和本地资源管理器两部分。**

**事务管理器相当于集中式的中央节点服务器负责协调，负责各个本地资源的提交和回滚**

**资源管理器就是分布式事务的参与者，通常由数据库实现**。

**两阶段提交协议执行过程，分为投票(voting)和提交(commit)两个阶段**。

- **第一阶段** 协调者会向事务参与者**发起执行操作的 cancommit 请求**，并**等待参与者响应**
  - 参与者收到请求后，会执行请求中的事务操作，**将操作记录记录到事务日志中但是不提交**。
  - **待参与者执行成功**，向协调者发送 YES 消息，表示同意操作，不成功发送NO消息，终止操作。
  - **当所有参与者都返回了操作结果后**，进入第二阶段提交/执行阶段
- **第二阶段提交/执行**
  - 如果协调者收到的**回复都是 YES 消息**，向参与者发送 **DoCommit** 消息
  - 参与者收到 **DoCommit** 消息后，完成剩余的操作并释放资源，向协调者返回 **HaveCommitted** 消息。
  - 如果协调者收到的消息**包含 NO 消息**，**向所有的参与者发送 DoAbort 消息**，之前投票发送 YES 消息的参与者，会根据之前执行操作的事务日志**对操作进行回滚**，然后所有参与者会向协调者**发送 HaveCommitted 消息**。
- **协调者收到所有参与者的 HaveCommitted 消息后，整个事务结束**。

两阶段提交每个阶段都是等待所有节点回复，协调者向参与者下发请求操作，参与者收到请求执行，通知协调者，协调者根据所有参与则会的回复在确定是否提交和回滚，有点四次🤝的感觉，尽量保证了数据的强一致性，但是这显然是不能够保证可靠性和可用性的。

- **同步阻塞等待**，参与者二阶段提交对资源存在竞争，阻塞传递导致真个事务阻塞，不能够支持高并发场景。
- **单点故障**，协调者故障，整个系统就挂了，如果在二阶段的提交阶段，数据库的资源可能也不能释放。
- **数据不一致**，提交阶段，协调者 **DoCommit** 通知参与者对操作提交，如果发生了局部网络异常，通知消息丢失，部分事务提交，部分事务没有被提交，导致数据不一致。

**Q**

**两阶段提交在协调者通知参与者提交阶段，通知消息丢失。**

1. **那这个事务结束结束吗？超时自动回滚？**
2. **协调者是否等到所有的参与者回复 HaveCommited消息才结束呢，如果失败会重发吗？**
3. **如果分布式节点跨数据中心，怎么搞，边缘网络能解决广域网传输问题吗？？？**

## 三阶段提交协议3PC

Three-phase Commit Protocol，3PC，是对两阶段提交 **2PC**的改进，为了处理两阶段提交的同步阻塞和数据不一致问题，3PC 引入了**超时机制和准备阶段**。

- 3PC的超时机制，如果协调者和参与者**在规定的时间内没有收到消息响应，就会根据当前的状态选择提交和终止事务**，从而减少整体阻塞时间，一定程度减轻了阻塞的程度。
- 在第一阶段和第二阶段中间加入了一个准备阶段，或者将2PC的投票的第一阶段分为两步，**提交阶段前加入一个预提交阶段**，在预提交阶段尽可能排除一些不一致的情况，保证最后提交阶段之前各参与阶段的状态是一致的。
- 增加一次消息通信确认来尽可能保证数据一致，实现用 UDP 吗？

------

### CanCommit(vote)

协调者向参与者**发送请求询问(CanCommit 请求)**，**询问参与者是否可以顺利?执行事务提交操作**，等待参与者响应。

参与者收到CanCommit 请求之后，回复YES/NO，仅回复是否可以顺利执行事务，不写日志，这会可靠吗？？？

当收到**所有参与者**，还是所有，进入预提交阶段，是要来判断资源有没有争抢？能预料到之后的执行事务的死锁吗？

### PreCommit

- 如果所有参与者回复的都是YES，协调者会执行事务的预执行。
- 协调者向参与者发送 PreCommit 请求，进入预提交阶段。
- 参与者收到PreCommit 请求后执行事务操作，将Undo、Redo 信息记录到事务日志
- 如果参与者成功执行事务操作，对协调者进行ACK响应，等待最终提交指令
- **任何一个参与者向协调者发送了No消息，或者等待超时之后协调则会没有收到参与者的响应，就执行中断事务的操作**
- <u>Q: 这个超时时间是全局时间还是单个节点都是一个维护时间，能不能广播一下子把消息发出去？**能不能等待一个固定时间没有收到全数的ACK就中断事务回滚？**单个节点维护一个超时时间复杂了一点。</u>
- 如果事务被中断，协调者向所有参与者发送 About 消息
- 参与者收到 About 消息之后，或超时之后仍然未收到协调者的消息，执行事务的中断操作。
- <u>Q: **2PC引入一个超时时间 FAIL FAST 不行吗?，3PC 多一次通信感觉意义不大啊!**</u>

**这样确实能够保证在最后提交阶段，所有的参与者状态是一致的。**

### DoCommit

根据 PreCommit 阶段协调者发送的消息，进入执行提交或事务中断。

1. 提交
   - 如果收到所有参与者发送的 ACK响应，向所有参与者发送 DoCommit 消息，开始执行。
   - 参与者收到 DoCommit 消息之后，正式提交事务，完成事务提交之后，释放所有锁住的资源，并向协调者发送ACK响应。
   - 协调者收到所有参与者ACK 响应后，完成事务。
2. 中断
   - 协调者向所有参与者发送 Abort 请求
   - 参与者接受到Abort 消息之后，利用其在PreCommit 阶段记录的 Undo 信息执行事务的回滚操作
   - 释放所有锁住的资源，并向协调者发送ACK消息。
   - 协调者收到参与者反馈的ACK消息之后，执行事务的中断，结束事务。

### 参与者超时自动提交(DoCommit)

**3PC 协议在协调者和参与者中都引入了超时机制，参与者ACK通知协调者，如果等待协调者ACK超时，默认情况下会自动超时提交，减少整个集群的提交，一定程度减轻了2PC的阻塞问题。**

### 3PC的不一致(PreCommit)

PreCommit 阶段，参与者未收到协调者ACK，无法写log，预执行任务，导致数据不一致。

分布式里面，2PC，3PC 需要所有的节点同步参与通信，通信消息密集，并且还是依赖数据库的实现，数据库还得保证网络的稳定，协议也不是FAIL FAST，这个协议不就是个KPI吗。

## 基于分布式消息的最终一致性

2PC、3PC以集中式架构，同步执行、通信，存在数据不一致情况，根本不能够满足大部分场景。

分布式的事务，通过消息或者日志异步执行，通过承载相应的信息的数据库或者消息队列组件来处理。

引入MQ，以购物事件为例

1. 用户下单到订单系统，订单通过消息请求MQ持久化
2. MQ持久化成功，订单系统持久化订单信息，通知MQ投递订单消息去支付，MQ持久化失败，删除消息，响应订单系统。
3. 支付系统消费消息，进行支付，支付完成在投递到新的状态队列
4. 仓库系统消费支付完成的订单状态队列，完成下单

------

异常情况

1. 订单信息投递MQ持久化失败，订单系统就没有后续，直接失败
2. MQ 投递到待支付队列，支付系统支付成功ACK回传MQ失败，订单系统和支付系统不一致，需要MQ进行重试，这个时候不能回滚，不能让支付系统支付成功的退钱吧。
3. 支付成功ACK成功，订单ACK失败，MQ需要确认结果一致性，进行重试或删除。

基于MQ 消息的异步通信，避免了通信阻塞，提高了吞吐量，可以确保一致性，并且屏蔽了不同系统协议的规范，需要MQ系统的高可用支撑，避免了2PC、3PC 保证强一致性很大几率的数据不一致，成功率更高。

<u>**Q: 这里的MQ 算是解耦吗？**</u>

|              | 2PC      | 3PC        | MQ     |
| ------------ | -------- | ---------- | ------ |
| 一致性类别   | 强一致性 | 强一致性   | 最终一 |
| 执行方式     | 同步     | 同步       | 异步   |
| 同步阻塞问题 | 存在     | 存在(较轻) | 不存在 |
| 单点故障     | 存在     | 存在       | 不存在 |
| 吞吐量/并发  | 低       | 中         | 高     |
| 实现难度     | 简单     | 简单       | 复杂   |
| 性能         | 低       | 低         | 高     |

## 刚性/柔性事务

- 刚性事务

  遵循ACID原则，强一致性

- 柔性事务

  根据业务容忍度实现最终一致性，容忍一定时间内数据不一致。

## BASE理论

eBay 的 Dan Pritchett 提出分布式存储系统的设计模式 - BASE 理论。

**BASE理论包括 **

**基本可用(Basically Available)  允许部分功能不可用(降级)，保证核心功能可用。**

**柔性状态(Soft State) 允许系统存在中间状态，中间状态不会影响系统整体可用性，eg: 数据库的主从延时。**

**最终一致性(Eventual Consistency) 数据的暂时不一致，最终一致。**

分布式MQ 消息通信来延迟达到数据最终一致，就是遵循的 BASE 理论。

MQ 中的需要对处理异常、消费幂等、重试，啊啊啊。

## 分布式事务一致性分类

### 宽松一致性

- 无中间态 xa、消息

- 有中间态 TCC，SAGA

- MSG

回滚问题

### 方案

- seata
- himly
- tcc-transaction
- ByteTCC
- 本地消息表
- 对账补偿 允许不一致，检测不一致情况进行补偿，工作量大
